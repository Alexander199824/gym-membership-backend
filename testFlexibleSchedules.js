// scripts/testFlexibleSchedules.js - NUEVO: Script de testing completo
const { GymHours, GymTimeSlots } = require('./src/models');

// ‚úÖ COLORES PARA CONSOLA
const colors = {
  green: '\x1b[32m',
  red: '\x1b[31m',
  yellow: '\x1b[33m',
  blue: '\x1b[34m',
  reset: '\x1b[0m',
  bright: '\x1b[1m'
};

const log = {
  success: (msg) => console.log(`${colors.green}‚úÖ ${msg}${colors.reset}`),
  error: (msg) => console.log(`${colors.red}‚ùå ${msg}${colors.reset}`),
  warning: (msg) => console.log(`${colors.yellow}‚ö†Ô∏è  ${msg}${colors.reset}`),
  info: (msg) => console.log(`${colors.blue}‚ÑπÔ∏è  ${msg}${colors.reset}`),
  title: (msg) => console.log(`\n${colors.bright}${colors.blue}üß™ ${msg}${colors.reset}`)
};

class FlexibleScheduleTester {
  
  constructor() {
    this.testResults = {
      passed: 0,
      failed: 0,
      warnings: 0
    };
  }

  async runAllTests() {
    log.title('INICIANDO TESTS DE HORARIOS FLEXIBLES');
    
    try {
      await this.testDatabaseConnection();
      await this.testModelAssociations();
      await this.testBasicOperations();
      await this.testFlexibleScheduleOperations();
      await this.testValidations();
      await this.testCapacityMetrics();
      await this.testEdgeCases();
      await this.testPerformance();
      
      this.printSummary();
    } catch (error) {
      log.error(`Error cr√≠tico en testing: ${error.message}`);
      process.exit(1);
    }
  }

  async testDatabaseConnection() {
    log.title('Test 1: Conexi√≥n a Base de Datos');
    
    try {
      // Verificar conexi√≥n
      await GymHours.findAll({ limit: 1 });
      log.success('Conexi√≥n a base de datos exitosa');
      
      // Verificar que las tablas existen
      const tableExists = await this.checkTableExists('gym_time_slots');
      if (tableExists) {
        log.success('Tabla gym_time_slots existe');
      } else {
        log.error('Tabla gym_time_slots no existe - ejecutar migraci√≥n');
        this.testResults.failed++;
        return;
      }
      
      this.testResults.passed++;
    } catch (error) {
      log.error(`Error de conexi√≥n: ${error.message}`);
      this.testResults.failed++;
    }
  }

  async testModelAssociations() {
    log.title('Test 2: Asociaciones de Modelos');
    
    try {
      // Verificar asociaci√≥n GymHours -> GymTimeSlots
      if (GymHours.associations && GymHours.associations.timeSlots) {
        log.success('Asociaci√≥n GymHours.timeSlots configurada');
      } else {
        log.error('Asociaci√≥n GymHours.timeSlots no configurada');
        this.testResults.failed++;
      }
      
      // Verificar asociaci√≥n GymTimeSlots -> GymHours
      if (GymTimeSlots.associations && GymTimeSlots.associations.gymHours) {
        log.success('Asociaci√≥n GymTimeSlots.gymHours configurada');
      } else {
        log.error('Asociaci√≥n GymTimeSlots.gymHours no configurada');
        this.testResults.failed++;
      }
      
      // Test de consulta con asociaci√≥n
      const testDay = await GymHours.findOne({
        include: [{
          association: 'timeSlots',
          required: false
        }]
      });
      
      if (testDay) {
        log.success('Consulta con asociaci√≥n funciona correctamente');
        this.testResults.passed++;
      } else {
        log.warning('No hay datos para probar asociaciones');
        this.testResults.warnings++;
      }
      
    } catch (error) {
      log.error(`Error en asociaciones: ${error.message}`);
      this.testResults.failed++;
    }
  }

  async testBasicOperations() {
    log.title('Test 3: Operaciones B√°sicas');
    
    try {
      // Test: Obtener horario semanal tradicional
      const traditionalSchedule = await GymHours.getWeeklySchedule();
      if (traditionalSchedule && Object.keys(traditionalSchedule).length === 7) {
        log.success('getWeeklySchedule() funciona correctamente');
      } else {
        log.error('getWeeklySchedule() no funciona');
        this.testResults.failed++;
        return;
      }
      
      // Test: Obtener horario flexible
      const flexibleSchedule = await GymHours.getFlexibleSchedule();
      if (flexibleSchedule && Object.keys(flexibleSchedule).length === 7) {
        log.success('getFlexibleSchedule() funciona correctamente');
      } else {
        log.error('getFlexibleSchedule() no funciona');
        this.testResults.failed++;
        return;
      }
      
      // Test: Verificar estructura de datos
      const mondaySchedule = flexibleSchedule.monday;
      if (mondaySchedule && typeof mondaySchedule.isOpen === 'boolean' && Array.isArray(mondaySchedule.timeSlots)) {
        log.success('Estructura de datos es correcta');
      } else {
        log.error('Estructura de datos incorrecta');
        this.testResults.failed++;
        return;
      }
      
      // Test: isOpenNow
      const isOpen = await GymHours.isOpenNow();
      if (typeof isOpen === 'boolean') {
        log.success(`isOpenNow() funciona - gym est√° ${isOpen ? 'abierto' : 'cerrado'}`);
      } else {
        log.error('isOpenNow() no funciona correctamente');
        this.testResults.failed++;
      }
      
      this.testResults.passed++;
    } catch (error) {
      log.error(`Error en operaciones b√°sicas: ${error.message}`);
      this.testResults.failed++;
    }
  }

  async testFlexibleScheduleOperations() {
    log.title('Test 4: Operaciones de Horarios Flexibles');
    
    try {
      // Test: Alternar d√≠a abierto/cerrado
      const originalState = await GymHours.findOne({ where: { dayOfWeek: 'monday' } });
      const originalIsClosed = originalState.isClosed;
      
      await GymHours.toggleDayOpen('monday');
      const toggledState = await GymHours.findOne({ where: { dayOfWeek: 'monday' } });
      
      if (toggledState.isClosed !== originalIsClosed) {
        log.success('toggleDayOpen() funciona correctamente');
        
        // Restaurar estado original
        await GymHours.toggleDayOpen('monday');
      } else {
        log.error('toggleDayOpen() no funciona');
        this.testResults.failed++;
      }
      
      // Test: Agregar franja horaria
      const testSlotData = {
        open: '10:00',
        close: '12:00',
        capacity: 25,
        reservations: 0,
        label: 'Test Slot'
      };
      
      const newSlot = await GymHours.addTimeSlot('monday', testSlotData);
      if (newSlot && newSlot.openTime === '10:00:00') {
        log.success('addTimeSlot() funciona correctamente');
        
        // Test: Eliminar franja (marcar como inactiva)
        newSlot.isActive = false;
        await newSlot.save();
        log.success('Eliminaci√≥n de slot funciona correctamente');
      } else {
        log.error('addTimeSlot() no funciona');
        this.testResults.failed++;
      }
      
      this.testResults.passed++;
    } catch (error) {
      log.error(`Error en operaciones flexibles: ${error.message}`);
      this.testResults.failed++;
    }
  }

  async testValidations() {
    log.title('Test 5: Validaciones');
    
    try {
      let validationsPassed = 0;
      
      // Test: Validaci√≥n de hora inv√°lida
      try {
        await GymTimeSlots.create({
          gymHoursId: 1,
          openTime: '25:00', // Hora inv√°lida
          closeTime: '26:00',
          capacity: 30
        });
        log.error('Validaci√≥n de hora inv√°lida fall√≥');
      } catch (error) {
        log.success('Validaci√≥n de hora inv√°lida funciona');
        validationsPassed++;
      }
      
      // Test: Validaci√≥n de capacidad
      try {
        await GymTimeSlots.create({
          gymHoursId: 1,
          openTime: '09:00',
          closeTime: '10:00',
          capacity: 600 // Capacidad excesiva
        });
        log.error('Validaci√≥n de capacidad fall√≥');
      } catch (error) {
        log.success('Validaci√≥n de capacidad funciona');
        validationsPassed++;
      }
      
      // Test: Validaci√≥n de orden temporal
      try {
        await GymTimeSlots.create({
          gymHoursId: 1,
          openTime: '15:00',
          closeTime: '10:00', // Cierre antes de apertura
          capacity: 30
        });
        log.error('Validaci√≥n de orden temporal fall√≥');
      } catch (error) {
        log.success('Validaci√≥n de orden temporal funciona');
        validationsPassed++;
      }
      
      if (validationsPassed >= 2) {
        this.testResults.passed++;
      } else {
        this.testResults.failed++;
      }
      
    } catch (error) {
      log.error(`Error en validaciones: ${error.message}`);
      this.testResults.failed++;
    }
  }

  async testCapacityMetrics() {
    log.title('Test 6: M√©tricas de Capacidad');
    
    try {
      const metrics = await GymHours.getCapacityMetrics();
      
      if (metrics && typeof metrics === 'object') {
        log.success('getCapacityMetrics() devuelve datos');
        
        // Verificar propiedades esperadas
        const expectedProps = ['totalCapacity', 'totalReservations', 'availableSpaces', 'averageOccupancy'];
        const hasAllProps = expectedProps.every(prop => metrics.hasOwnProperty(prop));
        
        if (hasAllProps) {
          log.success('M√©tricas tienen todas las propiedades esperadas');
          log.info(`Capacidad total: ${metrics.totalCapacity}`);
          log.info(`Reservas actuales: ${metrics.totalReservations}`);
          log.info(`Ocupaci√≥n promedio: ${metrics.averageOccupancy}%`);
        } else {
          log.error('Faltan propiedades en m√©tricas');
          this.testResults.failed++;
          return;
        }
        
        this.testResults.passed++;
      } else {
        log.error('getCapacityMetrics() no funciona');
        this.testResults.failed++;
      }
      
    } catch (error) {
      log.error(`Error en m√©tricas: ${error.message}`);
      this.testResults.failed++;
    }
  }

  async testEdgeCases() {
    log.title('Test 7: Casos Edge');
    
    try {
      let edgeTestsPassed = 0;
      
      // Test: D√≠a sin franjas horarias
      const emptyDaySchedule = await GymHours.getFlexibleSchedule();
      const emptyDay = Object.values(emptyDaySchedule).find(day => 
        day.isOpen === false || day.timeSlots.length === 0
      );
      
      if (emptyDay) {
        log.success('Manejo de d√≠as sin franjas funciona');
        edgeTestsPassed++;
      }
      
      // Test: M√∫ltiples franjas en un d√≠a
      const busyDay = Object.values(emptyDaySchedule).find(day => 
        day.timeSlots && day.timeSlots.length > 1
      );
      
      if (busyDay) {
        log.success('Manejo de m√∫ltiples franjas funciona');
        edgeTestsPassed++;
      } else {
        log.warning('No hay d√≠as con m√∫ltiples franjas para probar');
        this.testResults.warnings++;
      }
      
      // Test: Medianoche (casos de horario 24h)
      try {
        const midnightTest = await GymTimeSlots.create({
          gymHoursId: 1,
          openTime: '23:00',
          closeTime: '23:59',
          capacity: 10,
          isActive: false // No interferir con datos reales
        });
        
        if (midnightTest) {
          log.success('Manejo de horarios nocturnos funciona');
          edgeTestsPassed++;
          
          // Limpiar test data
          await midnightTest.destroy();
        }
      } catch (error) {
        log.warning(`Test de medianoche fall√≥: ${error.message}`);
        this.testResults.warnings++;
      }
      
      if (edgeTestsPassed >= 1) {
        this.testResults.passed++;
      } else {
        this.testResults.failed++;
      }
      
    } catch (error) {
      log.error(`Error en casos edge: ${error.message}`);
      this.testResults.failed++;
    }
  }

  async testPerformance() {
    log.title('Test 8: Performance');
    
    try {
      const iterations = 100;
      
      // Test: Performance de getFlexibleSchedule
      const start1 = Date.now();
      for (let i = 0; i < iterations; i++) {
        await GymHours.getFlexibleSchedule();
      }
      const time1 = Date.now() - start1;
      
      log.info(`getFlexibleSchedule() x${iterations}: ${time1}ms (${(time1/iterations).toFixed(2)}ms promedio)`);
      
      if (time1 / iterations < 100) { // Menos de 100ms por consulta
        log.success('Performance de consultas es aceptable');
      } else {
        log.warning('Performance de consultas es lenta');
        this.testResults.warnings++;
      }
      
      // Test: Performance de getCapacityMetrics
      const start2 = Date.now();
      for (let i = 0; i < 10; i++) {
        await GymHours.getCapacityMetrics();
      }
      const time2 = Date.now() - start2;
      
      log.info(`getCapacityMetrics() x10: ${time2}ms (${(time2/10).toFixed(2)}ms promedio)`);
      
      if (time2 / 10 < 200) { // Menos de 200ms por consulta de m√©tricas
        log.success('Performance de m√©tricas es aceptable');
      } else {
        log.warning('Performance de m√©tricas es lenta');
        this.testResults.warnings++;
      }
      
      this.testResults.passed++;
      
    } catch (error) {
      log.error(`Error en tests de performance: ${error.message}`);
      this.testResults.failed++;
    }
  }

  async checkTableExists(tableName) {
    try {
      const [results] = await GymHours.sequelize.query(
        `SELECT table_name FROM information_schema.tables WHERE table_name = '${tableName}';`
      );
      return results.length > 0;
    } catch (error) {
      return false;
    }
  }

  printSummary() {
    log.title('RESUMEN DE TESTS');
    
    console.log(`\n${colors.bright}üìä RESULTADOS:${colors.reset}`);
    console.log(`${colors.green}‚úÖ Pasados: ${this.testResults.passed}${colors.reset}`);
    console.log(`${colors.red}‚ùå Fallados: ${this.testResults.failed}${colors.reset}`);
    console.log(`${colors.yellow}‚ö†Ô∏è  Advertencias: ${this.testResults.warnings}${colors.reset}`);
    
    const total = this.testResults.passed + this.testResults.failed;
    const successRate = total > 0 ? ((this.testResults.passed / total) * 100).toFixed(1) : 0;
    
    console.log(`\n${colors.bright}üìà Tasa de √©xito: ${successRate}%${colors.reset}`);
    
    if (this.testResults.failed === 0) {
      log.success('¬°TODOS LOS TESTS CR√çTICOS PASARON! üéâ');
    } else {
      log.error(`${this.testResults.failed} tests fallaron. Revisar implementaci√≥n.`);
    }
    
    console.log(`\n${colors.blue}üí° RECOMENDACIONES:${colors.reset}`);
    
    if (this.testResults.failed > 0) {
      console.log('- Revisar migraci√≥n de base de datos');
      console.log('- Verificar asociaciones de modelos');
      console.log('- Comprobar validaciones de datos');
    }
    
    if (this.testResults.warnings > 0) {
      console.log('- Considerar optimizaciones de performance');
      console.log('- Agregar m√°s datos de prueba');
      console.log('- Revisar casos edge espec√≠ficos');
    }
    
    if (this.testResults.failed === 0 && this.testResults.warnings === 0) {
      console.log('- ‚úÖ Sistema listo para producci√≥n');
      console.log('- ‚úÖ Considerar agregar tests de integraci√≥n con frontend');
      console.log('- ‚úÖ Documentar API endpoints');
    }
  }
}

// ‚úÖ FUNCI√ìN PRINCIPAL
async function runTests() {
  const tester = new FlexibleScheduleTester();
  await tester.runAllTests();
  
  // Exit code para CI/CD
  process.exit(tester.testResults.failed > 0 ? 1 : 0);
}

// ‚úÖ SCRIPT DE DATOS DE PRUEBA
async function seedTestData() {
  log.title('CREANDO DATOS DE PRUEBA');
  
  try {
    // Crear horarios flexibles de ejemplo para desarrollo/testing
    const days = ['monday', 'tuesday', 'wednesday', 'thursday', 'friday'];
    
    for (const day of days) {
      let dayRecord = await GymHours.findOne({ where: { dayOfWeek: day } });
      
      if (!dayRecord) {
        dayRecord = await GymHours.create({
          dayOfWeek: day,
          isClosed: false,
          useFlexibleSchedule: true
        });
      } else {
        dayRecord.useFlexibleSchedule = true;
        await dayRecord.save();
      }
      
      // Limpiar franjas existentes
      await GymTimeSlots.update(
        { isActive: false },
        { where: { gymHoursId: dayRecord.id } }
      );
      
      // Crear franjas de ejemplo
      const sampleSlots = [
        { open: '06:00', close: '12:00', capacity: 50, reservations: 25, label: 'Horario Ma√±ana' },
        { open: '14:00', close: '20:00', capacity: 80, reservations: 60, label: 'Horario Tarde' },
        { open: '20:00', close: '22:00', capacity: 30, reservations: 15, label: 'Horario Noche' }
      ];
      
      for (let i = 0; i < sampleSlots.length; i++) {
        const slot = sampleSlots[i];
        await GymTimeSlots.create({
          gymHoursId: dayRecord.id,
          openTime: slot.open,
          closeTime: slot.close,
          capacity: slot.capacity,
          currentReservations: slot.reservations,
          slotLabel: slot.label,
          displayOrder: i,
          isActive: true
        });
      }
      
      log.success(`Datos de prueba creados para ${day}`);
    }
    
    log.success('Datos de prueba creados exitosamente');
    
  } catch (error) {
    log.error(`Error creando datos de prueba: ${error.message}`);
  }
}

// Ejecutar si se llama directamente
if (require.main === module) {
  const command = process.argv[2];
  
  if (command === 'seed') {
    seedTestData();
  } else {
    runTests();
  }
}

module.exports = { FlexibleScheduleTester, seedTestData, runTests };